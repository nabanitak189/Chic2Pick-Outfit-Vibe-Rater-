import numpy as np
import cv2
from skimage.filters.rank import entropy
from skimage.morphology import disk
from skimage.color import rgb2gray
from skimage.util import img_as_ubyte
from sklearn.cluster import KMeans

# --- Basic helpers ---
def to_cv(image_pil):
    # PIL RGB -> OpenCV BGR
    return cv2.cvtColor(np.array(image_pil), cv2.COLOR_RGB2BGR)

def to_rgb(image_cv):
    return cv2.cvtColor(image_cv, cv2.COLOR_BGR2RGB)

def resize_for_analysis(img_rgb, max_side=1024):
    h, w = img_rgb.shape[:2]
    if max(h, w) <= max_side:
        return img_rgb
    scale = max_side / max(h, w)
    return cv2.resize(img_rgb, (int(w*scale), int(h*scale)), interpolation=cv2.INTER_AREA)

# --- Colorfulness (Hasler & SÃ¼sstrunk) ---
def colorfulness_score(img_rgb):
    img = img_rgb.astype("float")
    (R, G, B) = (img[:,:,0], img[:,:,1], img[:,:,2])
    rg = np.abs(R - G)
    yb = np.abs(0.5 * (R + G) - B)
    std_rg, mean_rg = np.std(rg), np.mean(rg)
    std_yb, mean_yb = np.std(yb), np.mean(yb)
    cf = np.sqrt(std_rg**2 + std_yb**2) + 0.3*np.sqrt(mean_rg**2 + mean_yb**2)
    # Normalize roughly to 0..100
    return float(np.clip(cf / 3.0, 0, 100))

# --- Edge density / complexity ---
def edge_complexity(img_rgb):
    gray = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2GRAY)
    gray_blur = cv2.GaussianBlur(gray, (5,5), 0)
    edges = cv2.Canny(gray_blur, 50, 150)
    density = edges.mean() * 100.0 / 255.0  # percent of edge pixels
    return float(np.clip(density*2.0, 0, 100)), edges  # boost a little for visual scale

# --- Texture entropy / pattern density ---
def pattern_entropy(img_rgb):
    gray = rgb2gray(img_rgb)
    gray_u8 = img_as_ubyte(gray)
    ent = entropy(gray_u8, disk(5))
    score = float(np.clip(ent.mean()*10, 0, 100))  # scale to 0..100
    return score, ent

# --- Dominant colors ---
def dominant_colors(img_rgb, k=5):
    small = cv2.resize(img_rgb, (160, 160), interpolation=cv2.INTER_AREA)
    data = small.reshape(-1, 3)
    kmeans = KMeans(n_clusters=k, n_init=4, random_state=42)
    labels = kmeans.fit_predict(data)
    centers = kmeans.cluster_centers_.astype(np.uint8)
    counts = np.bincount(labels, minlength=k).astype(float)
    counts /= counts.sum()
    return centers, counts

# --- Fit tightness (heuristic using person mask) ---
def _mask_with_mediapipe(img_rgb):
    try:
        import mediapipe as mp
        mp_selfie = mp.solutions.selfie_segmentation.SelfieSegmentation(model_selection=1)
        with mp_selfie as model:
            res = model.process(img_rgb)
            mask = (res.segmentation_mask > 0.5).astype(np.uint8)*255
            return mask
    except Exception:
        return None

def fit_tightness(img_rgb):
    # Try to segment the person; fall back to central band analysis if not available
    mask = _mask_with_mediapipe(img_rgb)
    if mask is None:
        h, w = img_rgb.shape[:2]
        band = img_rgb[int(h*0.35):int(h*0.8), int(w*0.2):int(w*0.8)]
        edges = cv2.Canny(cv2.cvtColor(band, cv2.COLOR_RGB2GRAY), 60, 180)
        density = edges.mean()/255.0
        score = float(np.clip(100 - (density*120), 0, 100))  # more edges -> looser
        return score, None

    # Compute solidity of the biggest segmented region (person)
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not contours:
        return 50.0, None
    c = max(contours, key=cv2.contourArea)
    area = cv2.contourArea(c)
    hull = cv2.convexHull(c)
    hull_area = cv2.contourArea(hull) + 1e-6
    solidity = float(area / hull_area)
    # Tight fit -> smoother silhouette -> higher solidity
    score = float(np.clip(solidity * 100, 0, 100))
    return score, mask

def aggregate_scores(img_rgb):
    img_rgb = resize_for_analysis(img_rgb)
    color = colorfulness_score(img_rgb)
    complexity, edges = edge_complexity(img_rgb)
    pattern, ent = pattern_entropy(img_rgb)
    fit, mask = fit_tightness(img_rgb)

    # Derive "vibes"
    minimalist_vs_maximalist = np.clip((complexity*0.5 + pattern*0.35 + color*0.15), 0, 100)
    boldness = np.clip((color*0.6 + complexity*0.2 + pattern*0.2), 0, 100)

    return {
        "colorfulness": color,
        "complexity": complexity,
        "pattern_density": pattern,
        "fit_tightness": fit,
        "vibe_maximalism": float(minimalist_vs_maximalist),
        "boldness": float(boldness),
        "debug": {
            "edges": edges,
            "entropy": ent,
            "mask": mask
        },
        "processed_rgb": img_rgb
    }
